#  Docker学习

## 1.Docker入门

​	Docker是基于GO语言开发的。

​	Docker的主要目标是通过对应用组件的封装、分发、部署、运行等生命周期的管理，达到应用组件级别的“一次封装，导出运行”。

​	Docker引擎的基础是Linux容器技术。

​	Docker在开发和运维过程中，主要有如下几个优势：

- 是开发、测试、运维可以使用同一套环境来完成项目的交付和部署。
- Docker可以更高效的利用资源，Docker容器不需要额外的虚拟化管理程序，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。
- Docker几乎可以在各种平台上运行，较高的兼容性使得Docker可以在不同的平台之间无缝切换。
- 使用Dockerfile，采用增量的方式更新和分发，从而实现自动化并且高效的容器管理。

   Docker于虚拟机的比较：

|          | Docker                                        | 传统虚拟机                       |
| -------- | --------------------------------------------- | -------------------------------- |
| 速度     | 速度快，秒级启动                              | 启动较慢                         |
| 资源需求 | Docker对系统资源占用少                        | 虚拟化管理程序，对系统资源占用高 |
| 学习成本 | Docker通过命令行来操作，类似于git，学习成本低 | 虚拟化相关配置需要大量的只是经验 |
| 部署效率 | 统一通过Dockerfile来进行配置，部署效率高      | 没有统一的配置方式，部署效率低   |

![image-20200916102031297](Docker学习.assets/image-20200916102031297.png)

![image-20200916102628386](Docker学习.assets/image-20200916102628386.png)

## 2.Docker的核心概念

### 2.1 Docker镜像

​	Docker镜像类似于虚拟机镜像，可以将其理解为一个面向Docker引擎的只读模板，**包含了文件系统**。

​	例如：一个镜像可以只包含了一个完整的Ubuntn操作系统，可以把它称为一个Ubuntn镜像；也可以在Ubuntn中安装了其它的应用(比如Mysql)，这时也可以称其为Mysql镜像。

​	**镜像是创建Docker容器的基础。**

### 2.2Docker容器

​	Docker容器类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。

​	容器是从容器创建的应用运行实例。**镜像是静态的一个东西，好像一个模板，而容器在基于镜像的基础上，产生一个实例——容器**。

​	容器才有启动、开始、停止、删除等操作。

​	镜像是不变的，容器在启动的时候，会在镜像的最上层建立一个可写层，而镜像本身是不变的。

### 2.3Docker仓库

​	Docker仓库类似于代码仓库，是Docker集中存放镜像的地方。

​	注册服务器是用来存放Docker仓库的，服务器上存放多个仓库，仓库中存放一类镜像，多个仓库以不同的tag来区分。

​	Docker仓库有公有仓库和私有仓库之分。

​	Docker的仓库管理很像git。自己创建的镜像可以手动push到指定的仓库，也可以从远端仓库中pull一个镜像到本地。

## 3.Docker仓库的安装

​	Docker在主流的操作系统中都是支持的。包括windows、Linux及Mac操作系统。

### 3.1在Ubuntn上安装Docker

​	要在Ubuntn上安装Docker，需要保证Ubuntn版本在14.04以上版本。

```shell
#首先更新安装源
sudo apt-get update

#安装docker.io，此方式安装的可能不是最新的Docker，要安装最新版本可以参照Docker官网
sudo apt-get install -y docker.io

#查看Docker是否安装成功
 docker -v
```

### 3.2在Windows 10上安装Docker

## 4.镜像详解

​	Docker运行容器之前需要本地存在对应的镜像，如果镜像不在本地，则Docker会尝试从默认镜像仓库下载(默认使用Docker Hub)，用户可以自定义。

### 4.1获取镜像

​	通过` docker pull NAME[:tag]`从默认仓库拉取镜像，tag相当于镜像的版本，如果不显示指定，则默认拉取latest版本。 
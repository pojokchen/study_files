阻塞与非阻塞：
	阻塞：数据没就绪就一直等在那里，直到有数据返回，类似于食堂排队打饭
	非阻塞：非阻塞在遇到数据没好或是缓冲区满暂时无法写入时，会直接返回，稍后再去写或是其它操作。
同步与异步：
	同步：数据准备好后需要本身去处理数据
	异步：数据准备好后直接回调给调用者

同步阻塞：自身等在那里，知道可写或可读后，调用者再进行相应操作
同步非阻塞：当前不可读或不可写，此时调用者之间返回，调用者间歇性的轮询查询或等待通知，然后自身再进行相应操作
异步阻塞：不存在这种情况，因为异步的特性是回调调用者，直接把数据给了调用者，所以不会阻塞
异步非阻塞：调用者在遇到不可读或不可写的情况时，直接返回，当数据或缓冲区准备好后，直接回调给调用者

netty对传统IO(BIO)、NIO、AIO都是支持的
	BIO：在netty中是OIO（old IO），在netty中过时了，采用Thread-per connection模式
	NIO:对应不同的平台由三种方式，通用实现、Linux的Epoll实现、macOS/BSD的Kqueue实现，采用Reactor开发模式
	AIO：在netty中已移除，采用Proactor开发模式
	删除AIO的原因：
		1.Windows上AIO实现成熟，但是很少用作服务器
		2.Linux上AIO不够成熟
		3.Linux上AIO相比NIO提升很少
BIO和NIO相比不一定就差：
	1.BIO实现起来简单
	2.在特定场景下，并发下，连接少，并且未来也不会有太多的改变，那么BIO可能比NIO更适合
	 
netty对Reactor模式的支持：
	例子：
		饭店：需要迎宾、点菜、做菜、上菜、送客
	Reactor的三种开发模式：
		Reactor单线程模式：一个线程包揽所有的事情
		Reactor多线程模式：多个线程合作做一些事情，每个线程所涉及的范围都是一样的。
		Reactor主从线程模式：单独一个或几个主线程从事一项特定工作，然后若干线程来接手剩下的工作。
	Reactor开发模式的核心流程：
		注册感兴趣的事件-->轮询扫描是否有事件发生-->根据发生的事件做相应的处理

netty对Reactor模式的支持源码：
	
粘包和半包：
	粘包：客户端向服务器发送了ABC DEF消息，两个消息分开发送，正常情况下，服务器应该也是按相同顺序接收到了两个消息，但是在粘包情况下，服务器可能接收到的消息为ABCDEF，两条消息被粘连在一起了。
	半包：客户端发送同样的消息，但是服务器在接收的时候确是AB CD EF接收到了三条消息，将原先的消息拆分整合了，这就是半包
粘包和半包总是不按照我们既定的方式去组合数据，消息在传递过程中出现了不正常的现象，导致服务器接收的消息也是异常的。

粘包的原因是：每次写入的数据包很小，而网卡会对待发送的数据进行收集达到一定值后统一发出；或者服务器方在接收数据时不及时，导致两次消息都到了之后才接收，由于网卡设备是不知道消息的组合方式的，所以就有可能出现粘包现象。
半包的原因是：发送方一次写入的数据大于套接字缓冲区可容纳数据大小后，就会拆包发送；还有可能是发送的数据大于MTU规定，则必须拆包发送。
TCP是流式协议，消息之间无边界。UDP就没有这个问题。

解决方式：解决的思想就是要找出消息的边界
	1.将TCP长连接改为短链接，一次连接发送消息即只代表本次传输要发送的数据。
	2.封装成Framing（帧）的方式：
		2.1固定长度：客户端按预先协商好的固定长度发送消息，所发消息小于固定长度则补零等，而接收方只要按照定义的固定长度顺序读取消息即可。这种方式造成传输的浪费，（补零操作）。
		2.2分割符：采用特定的分割符对消息进行分割，接收方按照特定的分割符来读取消息。这种方式实现简单，相比上一种所需空间较小。但是接收方在读取数据时需要预先扫描数据内容，效率比较低。
		2.3在消息开头或结尾已几个固定字段来设置消息长度：接收方先解析设置长度的固定字段，解析出消息长度，再对消息解析。空间浪费较小，而且兼顾了解码效率。长度的限定需提前判定好可能的最大长度
		

	